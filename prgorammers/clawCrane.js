// https://programmers.co.kr/learn/courses/30/lessons/64061
// 2019 카카오 인턴십, Level 1

/*
- 이해
게임 화면은 "1 x 1" 크기의 칸들로 이루어진 "N x N" 크기의 정사각 격자, 오른쪽에는 바구니.
각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸.
모든 인형은 "1 x 1" 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있다.
게임 사용자는 가장 위에 있는 인형을 집어 올릴 수 있다.
집어 올린 인형은 바구니에 쌓인다. -> 스택
같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형 모두 제거한다.

입력:
- 게임 화면의 격자의 상태가 담긴 2차원 배열 board
- 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves

출력:
- 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를

- 계획
리턴할 답 변수를 0으로 초기화한다.
바구니를 빈 배열로 초기화한다. (stack)
moves를 순회한다.
  board를 순회한다.
    해당 칸에 인형이 있다면(0이 아니라면)
      그 인형을 꺼내 바구니에 담는다.
      방금 꺼낸 인형이 바구니 가장 위에 있는 인형과 같다면
        두 인형을 모두 제거하고 답에 2를 더한다.
        새롭게 맞닿은 두 인형이 같아도 제거하고 답에 2를 더한다. 이 과정을 두 인형이 다를 때까지 반복한다.
        반복문 탈출(다음 줄로 넘어가지 않기 위함)
      같지 않다면 인형을 바구니에 쌓는다.
      반복문 탈출(다음 줄로 넘어가지 않기 위함)

- 실행

- 회고
> 새롭게 맞닿은 두 인형이 같아도 제거하고 답에 2를 더한다. 이 과정을 두 인형이 다를 때까지 반복한다.
위 과정을 반복하지 않았는데 문제가 생기지 않았다. 이유 탐색할 것.
해결: 생각해보니까 하나씩 인형을 뽑아야 해서(그러니까 미리 쌓여있는 인형은 존재하지 않는다.), 위와 같은 상황은 발생하지 않는다.

다른 사람들의 풀이를 보니 transpose를 이용하는 법이 시간복잡도를 줄여주는 듯하다.
이용해볼 것.
 */

function solution(board, moves) {
  let answer = 0;
  const bucket = [];

  for (const move of moves) {
      for (const i in board) {
          if (board[i][move - 1] !== 0) {
              const pulled = board[i][move - 1];
              board[i][move - 1] = 0;
              
              if (pulled === bucket[bucket.length - 1]){
                  bucket.pop();
                  answer += 2;
                  break;
              } 
              
              bucket.push(pulled);
              break;
          }
      }
  }
  
  return answer;
}
