/*
동적 계획법이란?
- 해결한 작은 문제로 큰 문제를 해결하는 문제 풀이 방식
- 그리디나 백트래킹처럼 특정 알고리즘이 아닌 문제 해결 방식을 의미
- Dynamic Programming
  - 그런데 사실 Dynamic 하지도 않고, Programming과도 관련이 없다.
- 메모리를 많이 사용하는 대신 빠르다.
- 두 가지 방법론
  - 메모이제이션(Memoization)
  - 타뷸레이션(Tabulation)

메모이제이션
- 하향식 접근법
- 동적 게획법에서 작은 문제들의 결과는 항상 같다.
- 따라서 이 결과들을 메모리에 저장해 필요할 때 꺼내 쓰는 것이 메모이제이션.

타뷸레이션 
- 상향식 접근법
- 필요한 값들을 미리 계산해두는 것
- 메모이제이션은 필요할 때 계산한다면(Lazy evaluation), 타뷸레이션은 미리 계산해둔다. (Eager evaluation)
- 보통 코테에선 메모이제이션이 대부분이다.

문제 접근법
- 동적 계획법 유형은 키워드만으로 해댱 유형 문제임을 알기 어렵다.
- 그렇기 때문에 문제 유형을 알 수 없다면 다음을 확인해볼 것
  - 가장 작은 문제를 정의할 수 있는가?
  - 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는가?
  - 위 두 가지가 가능하다면 동적 계획법 문제
- 간혹 메모리를 너무 사용하여 통과할 수 없는 경우도 있다.
  - 이런 경우엔 백트래킹을 이용할 수 있지만, 코테에서 자주 나오진 않는다.
*/

// https://programmers.co.kr/learn/courses/30/lessons/12983

function solution(strs, t) {
  // 편의를 위해 t의 길이 + 1만큼 배열을 만든다.
  const dp = Array.from({ length: t.length + 1 }, () => 0);
  // 문자열 검사를 빠르게 하기 위해서 문자열 리스트를 set으로 만든다.
  const strsSet = new Set(strs);

  // 1부터 문자열 길이 + 1까지 루프를 돈다.
  for (let i = 1; i < t.length + 1; i += 1) {
    // 일단 해당 문자열의 최솟값은 무한으로 설정한다.
    dp[i] = Infinity;
    // 문자열을 자르면서 단어 조각을 찾기 위해 루프를 돈다.
    // 단어 조각은 5 이하기 때문에 마지막까지 자를 필요는 없다.
    for (let j = 1; j < Math.min(i + 1, 6); j += 1) {
      const start = i - j;
      const end = i;
      // 단어 조각이 있다면
      if (strsSet.has(t.slice(start, end))) {
        // 이전 조합과 더해서 최솟값인지 체크 후 대입한다.
        dp[i] = Math.min(dp[i], dp[i - j] + 1);
      }
    }
  }

  // 결과적으로 단어의 최솟값을 구할 수 있다. 만약 무한이라면 불가능한 조합이기 때문에 -1을 리턴한다.
  return dp[dp.length - 1] === Infinity ? -1 : dp[dp.length - 1];
}
